
class Game {
private:
// * Window variables
    SDL_Window *window;
    SDL_Renderer *renderer;

    // Font
    TTF_Font* font;
    
// * Variables for the window loop
    // Window loop
    SDL_Event windowEvent;
    SDL_Color windowColor = BLACK;
    bool windowRunning;


    // Display mode
    SDL_DisplayMode currentDisplayMode;
    bool fullscreenMode = false;

    // FPS
    float fps;
    bool showFPS = true;

    // Set the center of the coordinate system
    Point2D center = {WIDTH / 2, HEIGHT / 2};
    Point2D screenSize = {WIDTH, HEIGHT};

    // Text
    // ! NOTE: When i first tried to create 2 text objects, the program crashed. 
    // !       Turns out it was because I had used up all the memory on the stack, 
    // !       and therefore have to allocate future objects to the heap instead
    Text *fpsText;

    Text *cameraPositionDebugText;
    Text *cameraRotationDebugText;

// * Camera
    Camera camera = Camera(screenSize);

// * Map
    Map map;
    // "testMapVoid": 0, "testMapGround": 1, "testMapObjectLoader": N/A
    int mapID = 0;
    

// * Input
    // Get keyboard
    const Uint8 *keyboardState = SDL_GetKeyboardState(NULL);

    // Get mouse
    Point2D mousePosition;
    Uint32 mouseState = SDL_GetMouseState(&mousePosition.x, &mousePosition.y);
    
// * Game loop
    // Set variables for game ticker
    Uint32 currentTime;
    Uint32 elapsedTime;

    // Set variables for FPS counter
    Uint32 lastTime = SDL_GetTicks();
    Uint32 frameCount = 0;



// * Methods
    void handleEvents() {
        // * Movement
        // I have to handle movement events separately because the keyboardState is not necessarily only updated when an SDL_PollEvent is triggered
        camera.move(keyboardState);

        if (SDL_PollEvent(&windowEvent)) {
            if (SDL_QUIT == windowEvent.type) {
                windowRunning = false;
            }

            // * Keyboard
            if (SDL_KEYDOWN == windowEvent.type) {
                switch (windowEvent.key.keysym.sym) {
                    case SDLK_F11:
                        if (SDL_GetWindowFlags(window) & SDL_WINDOW_FULLSCREEN_DESKTOP) {
                            SDL_SetWindowFullscreen(window, 0);
                            SDL_ShowCursor(SDL_ENABLE);
                            
                            center = {WIDTH >> 1, HEIGHT >> 1};
                            screenSize = {WIDTH, HEIGHT};

                            fullscreenMode = false;
                        } else {
                            SDL_SetWindowFullscreen(window, SDL_WINDOW_FULLSCREEN_DESKTOP);
                            SDL_GetCurrentDisplayMode(0, &currentDisplayMode);
                            SDL_ShowCursor(SDL_DISABLE);

                            center = {currentDisplayMode.w >> 1, currentDisplayMode.h >> 1};
                            screenSize = {currentDisplayMode.w, currentDisplayMode.h};

                            // Set mouse position to center of screen 
                            SDL_WarpMouseInWindow(window, center.x, center.y);

                            fullscreenMode = true;
                        }

                        // Update the perspective projection constant
                        camera.perspectiveProjectionConstant = screenSize.y / camera.screenHeight_world;

                        break;
                    case SDLK_m:
                        std::cout << "Map ID: " << mapID << "\n";

                        switch (mapID % 2) {
                        case 0:
                            setMap("testMapVoid");
                            break;
                        case 1:
                            setMap("testMapGround");

                            mapID = -1; // ! Reset mapID on last map
                            break;
                        }

                        map = getMap();
                        mapID++;

                        break;
                        
                    default:
                        // logMessage("Key pressed: " + std::to_string(windowEvent.key.keysym.sym), __LOGGING_TRACE, __MAIN_LOGID);
                        //
                        // cameraMovementSpeed = (cameraMovementSpeedConstant / (static_cast<int>(fps) + 1));
                        // cameraMovementSpeed = cameraMovementSpeedConstant;
                        // cameraMovementSpeed = elapsedTime / 10.0f;
                        //
                        // logMessage("Camera movement speed: " + std::to_string(cameraMovementSpeed), __LOGGING_DEBUG, __MAIN_LOGID);
                        break;
                };
            }

            // * Mouse
            // If window is focused
            if (SDL_GetWindowFlags(window) & SDL_WINDOW_INPUT_FOCUS) {
                // Get mouse position
                mouseState = SDL_GetMouseState(&mousePosition.x, &mousePosition.y);
                mousePosition -= center;
                
                // If mouse is moved
                if (0 != (abs(mousePosition.x) + abs(mousePosition.y)) && fullscreenMode) {
                    // Rotate Camera
                    camera.rotate({
                        -(mousePosition.y) * 0.001f,
                        -(mousePosition.x) * 0.001f,
                        0.0f
                    }, {false, false, false});
                    // */

                    // Set mouse position to center of screen 
                    SDL_WarpMouseInWindow(window, center.x, center.y);

                    // Update cache- and rotation matrix
                }
            }
        }
    }

    void renderFrame() {
        // * Clear the renderer
        SDL_RenderClear(renderer);

        // * Draw new frame
        // FPS
        if (showFPS) {
            // -- Uint32 currentTime = SDL_GetTicks();
            // -- Uint32 elapsedTime = currentTime - lastTime;

            currentTime = SDL_GetTicks();
            elapsedTime = currentTime - lastTime;

            frameCount++;
            
            if (elapsedTime >= 1000) {
                fps = static_cast<float>(frameCount) / (elapsedTime / 1000.0f);
                
                //// std::cout << "FPS: " << fps << std::endl;
                //// logMessage("FPS: " + std::to_string(static_cast<int>(fps)), __LOGGING_INFO, __MAIN_LOGID);
                fpsText->updateText("FPS: " + std::to_string(static_cast<int>(fps)));
                // cameraDebugText->updateText("FPS: " + std::to_string(static_cast<int>(fps)));
                       
                lastTime = currentTime;
                frameCount = 0;
            }

            fpsText->renderText();
        }

        if (elapsedTime % 100 == 0) {
            cameraPositionDebugText->updateText("Position: " + camera.getPositionDebug());
            cameraRotationDebugText->updateText("Rotation: " + camera.getRotationDebug());
        }
        
        // Draw map
        for (Shape3D &shape : map.shapes) {
            drawShape(renderer, perspectiveProjection(camera, shape), WHITE, center, screenSize);
        };

        // Draw text
        cameraPositionDebugText->renderText();
        cameraRotationDebugText->renderText();

    }


public:
    Game(/* args */);
    ~Game();

    void run() {
        windowRunning = true;

        while (windowRunning) {
            // * Handle events
            handleEvents();

            // * Render frame
            renderFrame();

            // * Update the screen
            SDL_SetRenderDrawColor(renderer, windowColor.r, windowColor.g, windowColor.b, windowColor.a);
            SDL_RenderPresent(renderer);
        }
    }

};

Game::Game(/* args */) {
// * Initialize Libaries
    // Initialize SDL
    SDL_Init(SDL_INIT_EVERYTHING);
    
    // Initialize SDL_ttf
    if (TTF_Init() == -1) {
        std::cerr << "Failed to initialize SDL_ttf: " << TTF_GetError() << std::endl;
        return; 
    }

// * Window
    // Create a window
    window = SDL_CreateWindow("3D Renderer", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, WIDTH, HEIGHT, SDL_WINDOW_ALLOW_HIGHDPI);

    if (NULL == window) {
        std::cout << "Could not create window: " << SDL_GetError() << std::endl;
        // // ! return EXIT_FAILURE;
        return;
    }
    
    // Create a renderer
    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);

    if (NULL == renderer) {
        std::cout << "Could not create renderer: " << SDL_GetError() << std::endl;
        SDL_DestroyWindow(window);
        SDL_Quit();
        // // ! return EXIT_FAILURE;
        return;
    }

    std::cout << "Window and renderer created successfully" << std::endl;

    // Load font
    font = TTF_OpenFont(FONT_PATH, 16);

    if (font == nullptr) {
        std::cerr << "Failed to load font: " << TTF_GetError() << std::endl;
        return;
    }

// * Text
    //// std::cout << "Text contructor call " << std::endl;
    fpsText = new Text({0,  0}, font, renderer);

    cameraPositionDebugText = new Text({0, 30}, font, renderer);
    cameraRotationDebugText = new Text({0, 50}, font, renderer);

// * Map
    // Set map
    // ? setMap("testMapObjectLoader");
    setMap("testMapGround");

    // Load map
    map = getMap();
}

Game::~Game() {
    // * Free all text
    delete fpsText;

    delete cameraPositionDebugText;
    delete cameraRotationDebugText;

    // * Close the font
    TTF_CloseFont(font);

    // * Destroy the window and renderer
    SDL_DestroyWindow(window);
    SDL_DestroyRenderer(renderer);
    SDL_Quit();

    std::cout << "Window and renderer destroyed successfully" << std::endl;
}

